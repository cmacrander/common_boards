// Generated by CoffeeScript 1.6.3
(function() {
  var PlayApp, includedProperties,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.getScope = function() {
    return angular.element($('#main')).scope();
  };

  includedProperties = ['_cbId', '_cbPieceName', '_cbLocked', '_cbOriginalWidth', '_cbOriginalHeight'];

  window.getRequestStringData = function() {
    var d, data, p, pairs, _i, _len;
    pairs = window.location.search.substring(1).split('&');
    data = {};
    for (_i = 0, _len = pairs.length; _i < _len; _i++) {
      p = pairs[_i];
      d = p.split('=');
      data[d[0]] = d[1];
    }
    return data;
  };

  PlayApp = angular.module('PlayApp', []);

  PlayApp.directive('ngMainCanvas', function() {
    return function($scope, element, attrs) {
      var options;
      options = {
        containerClass: 'twelve columns alpha'
      };
      $scope.canvas = new fabric.Canvas(element.attr('id'), options);
      $scope.canvas.setDimensions({
        width: 700,
        height: 644
      });
      $scope.canvas.on('object:selected', function(options) {
        return $scope.$apply(function() {
          return $scope.currentPiece = options.target;
        });
      });
      $scope.canvas.on('selection:cleared', function(options) {
        return $scope.$apply(function() {
          return $scope.currentPiece = false;
        });
      });
      return $scope.canvas.on('object:moving', function(options) {
        return $scope.$apply(function() {
          return $scope.pieceMoving(options);
        });
      });
    };
  });

  window.PlayCtrl = function($scope) {
    var data, dispatchers, handlers, webSocket;
    $scope.$safeApply = function(fn) {
      var phase;
      phase = this.$root.$$phase;
      if (phase === '$apply' || phase === '$digest') {
        if (fn && (typeof fn === 'function')) {
          return fn();
        }
      } else {
        return this.$apply(fn);
      }
    };
    $scope.tabs = {
      props: {
        selected: true
      },
      players: {
        selected: false
      }
    };
    $scope.players = {};
    $scope.pieces = {};
    $scope.currentPiece = false;
    $scope.motionLabels = {};
    $scope.motionLabelTimeouts = {};
    data = getRequestStringData();
    $scope.gameId = data.gameId;
    $scope.userName = data.userName;
    $scope.selectTab = function(tabName) {
      var name, t, _ref;
      _ref = $scope.tabs;
      for (name in _ref) {
        t = _ref[name];
        t.selected = false;
      }
      return $scope.tabs[tabName].selected = true;
    };
    $scope.lockPiece = function(o) {
      o.lockMovementX = o.lockMovementY = o.lockRotation = o.lockScalingX = o.lockScalingY = o.lockUniScaling = o._cbLocked;
      return o.set('hasControls', !o._cbLocked);
    };
    $scope.allowTranslationOnly = function(o) {
      o.set('hasControls', false);
      if (o._cbLocked) {
        return $scope.lockPiece(o);
      } else {
        return o.lockRotation = o.lockScalingX = o.lockScalingY = o.lockUniScaling = true;
      }
    };
    $scope.sendToBack = function() {
      return $scope.canvas.sendToBack($scope.currentPiece);
    };
    $scope.bringToFront = function() {
      return $scope.canvas.bringToFront($scope.currentPiece);
    };
    $scope.pieceMoving = function(options) {
      var newValueDict;
      newValueDict = {
        left: options.target.left,
        top: options.target.top
      };
      return webSocket.setObjectProperties(options.target._cbId, newValueDict);
    };
    $scope.saveGame = function() {
      var id, label, _ref, _results;
      _ref = $scope.motionLabels;
      _results = [];
      for (id in _ref) {
        label = _ref[id];
        _results.push($scope.canvas.remove(label));
      }
      return _results;
    };
    handlers = {
      error: function(msg) {
        return console.error(msg);
      },
      setGameState: function(msg) {
        return $scope.$apply(function() {
          var callback;
          $scope.gameName = msg.gameName;
          callback = function() {
            return $scope.canvas.forEachObject(function(o) {
              $scope.allowTranslationOnly(o);
              return $scope.pieces[o._cbId] = o;
            });
          };
          return $scope.canvas.loadFromJSON(msg.gameState, callback);
        });
      },
      playersUpdate: function(msg) {
        return $scope.$apply(function() {
          var id, label, name, _ref, _results;
          $scope.players = msg.players;
          $scope.motionLabels = {};
          _ref = $scope.players;
          _results = [];
          for (id in _ref) {
            name = _ref[id];
            label = new fabric.Text(name, {
              fontSize: 18
            });
            _results.push($scope.motionLabels[id] = label);
          }
          return _results;
        });
      },
      setObjectProperties: function(msg) {
        return $scope.$apply(function() {
          var callback, label, o, p, v, _ref, _ref1;
          o = $scope.pieces[msg.objectId];
          _ref = msg.newValueDict;
          for (p in _ref) {
            v = _ref[p];
            o.set(p, v);
          }
          o.setCoords();
          if ('left' in msg.newValueDict && 'top' in msg.newValueDict) {
            label = $scope.motionLabels[msg.senderId];
            if (_ref1 = msg.senderId, __indexOf.call($scope.motionLabelTimeouts, _ref1) < 0) {
              $scope.canvas.add(label);
            } else {
              clearTimeout($scope.motionLabelTimeouts[msg.senderId]);
            }
            callback = function() {
              $scope.canvas.remove(label);
              return delete $scope.motionLabelTimeouts[msg.senderId];
            };
            $scope.motionLabelTimeouts[msg.senderId] = setTimeout(callback, 1000);
            label.set('left', msg.newValueDict.left - 50);
            label.set('top', msg.newValueDict.top - 50);
            label.setCoords();
          }
          return $scope.canvas.renderAll();
        });
      }
    };
    dispatchers = {
      enterGame: function(userName, gameId) {
        return {
          messageType: 'enterGame',
          userName: $scope.userName,
          gameId: $scope.gameId
        };
      },
      setObjectProperties: function(objectId, newValueDict) {
        return {
          messageType: 'setObjectProperties',
          gameId: $scope.gameId,
          objectId: objectId,
          newValueDict: newValueDict
        };
      }
    };
    webSocket = window.initializeWebSocket(handlers, dispatchers);
    return webSocket.onopen = function() {
      return webSocket.enterGame();
    };
  };

  window.ControlCtrl = function($scope) {};

  $(document).ready(function() {
    return $("#add_piece_dialog").dialog({
      autoOpen: false,
      height: 500,
      width: 600,
      modal: true
    });
  });

}).call(this);
