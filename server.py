import os
import sys
import json
# import re           # for fixing weird json generated by svg2gfx.xslt
import string       # for generating random ids
import random       # for generating random ids
import time         # for determining if empty games are expired
import redis
from twisted.internet import reactor
from twisted.python import log
from twisted.web.server import Site
from twisted.web.static import File
from autobahn.websocket import WebSocketServerFactory, \
                               WebSocketServerProtocol, \
                               listenWS


### FUNCTIONS ###

def generateRandomString():
    """Return random 20 char string matching [A-Za-z0-9]"""
    size = 20
    chars = string.ascii_uppercase + string.ascii_lowercase + string.digits
    return ''.join(random.choice(chars) for x in range(size))

### CLASSES ###


class Envelope:
    """Simple container for organizing messages."""
    def __init__(self, msgDict, receivingClients):
        self.msgDict = msgDict
        self.receivingClients = receivingClients


class GameRegistry:
    """
    Singleton class for keeping track of active games and clients in the lobby.
    """
    def __init__(self):
        self._registry = {}
        self.lobby = Lobby()

    def add(self, game):
        self._registry[game.id] = game

    def delete(self, game):
        if game.id in self._registry:
            del self._registry[game.id]

    def get(self, gameId):
        return self._registry[gameId]

    def getAll(self):
        return [game for id, game in self._registry.items()]

    def gameExists(self, gameId):
        if not isinstance(gameId, str) and not isinstance(gameId, unicode):
            raise Exception('non-string provided')
        return gameId in self._registry

    def getLobbyUpdate(self):
        """
        Remove expired games and wrangle data for people in the lobby.
        Return envelope
        """
        self._cleanUp()

        returnDict = {'messageType': 'lobbyUpdate', 'gameList': []}
        for gameId, game in self._registry.items():
            gameDict = {
                'id': game.id,
                'name': game.name,
                'type': game.type,
                'clients': game.getClientNames()
            }
            returnDict['gameList'].append(gameDict)

        return Envelope(returnDict, self.lobby.getAll())

    def _cleanUp(self):
        """Delete empty, abandoned, old games."""
        for game in self.getAll():
            if game.isExpired():
                self.delete(game)


class Lobby:
    """
    Singleton class, created by the GameRegistry, for tracking clients
    in the lobby.
    """
    def __init__(self):
        self._lobbyClients = []

    def add(self, client):
        """Add client, making sure not to record duplicates"""
        if not client in self._lobbyClients:
            self._lobbyClients.append(client)

    def delete(self, client):
        """Delete client, but don't complain if they don't exist."""
        if client in self._lobbyClients:
            self._lobbyClients.remove(client)

    def getAll(self):
        return self._lobbyClients


class Game:
    """Contains a game state instance and clients in the game."""
    expiresIn = 60  # sec
    _clients = {}
    timeAbandoned = None

    @classmethod
    def generateId(klass):
        return 'game_' + generateRandomString()

    def __init__(self, gameTypeId, name, state=None):
        """For creating a new game."""
        self.id = Game.generateId()
        self.typeId = gameTypeId
        self.type = redisDb.hget(gameTypeId, 'name')
        self.name = name
        if state is None:
            self.state = GameState(gameTypeId=gameTypeId)
        else:
            self.state = state

    @classmethod
    def load(self, id):
        """For loading a saved game."""
        gameDict = redisDb.hgetall(id)
        # The state information is encoded in redis as a JSON string
        # The gameState object expects exactly this.
        gameState = GameState(stateString=gameDict['stateString'])
        return Game(gameDict['type'], gameDict['name'], state=gameState)

    def save(self):
        redisDb.hmset(self.id, {
            'id': self.id,
            'type': self.type,
            'name': self.name,
            'stateString': str(self.state),  # see GameState.__str__()
        })
        redisDb.sadd('allGames', self.id)

    def addClient(self, client, name):
        client.name = name
        if not client.peerstr in self._clients:
            self._clients[client.peerstr] = client

    def deleteClient(self, client):
        """
        Both delete client from this game and, if the game becomes empty
        as a result, mark the time it was abandoned.
        """
        if client.peerstr in self._clients:
            del(self._clients[client.peerstr])

        if len(self._clients) == 0:
            self.timeAbandoned = time.time()

    def hasClient(self, client):
        return client.peerstr in self._clients

    def getClientList(self):
        return [c for id, c in self._clients.items()]

    def getClient(self, id):
        return self._clients[id]

    def getClientNames(self):
        """Return tuple of user-entered names for display."""
        return tuple(c.name for id, c in self._clients.items())

    def getPlayersUpdate(self):
        """
        Wrangle data about who is in this game for display. Return envelope.
        """
        msgDict = {'messageType': 'playersUpdate',
                   'players': {c.peerstr : c.name for c in self.getClientList()}}
        return Envelope(msgDict, self.getClientList())

    def isExpired(self):
        """Return boolean; true only if empty, abandoned, and old."""
        if len(self._clients) == 0 and not self.timeAbandoned is None:
            return time.time() - self.timeAbandoned > self.expiresIn
        else:
            return False


class GameState:
    """Contains current information about the game pieces."""

    def __init__(self, gameTypeId=None, stateString=None):
        if gameTypeId is None and stateString is None:
            raise Exception('Insufficient parameters.')
        elif gameTypeId and stateString:
            raise Exception('Too many parameters.')
        elif gameTypeId:
            stateString = redisDb.hget(gameTypeId, 'stateString')
        self._fullState = json.loads(stateString)
        # keep the objects in the state in a nicely indexed dictionary so
        # they can be easily looked up and changed
        self._objectIndex = {}
        for d in self._fullState[u'objects']:
            self._objectIndex[d[u'_cbId']] = d

    def __str__(self):
        return json.dumps(self.get())

    def get(self):
        # the most current version of the objects are in the index
        # so put them back into the state and return it
        self._fullState[u'objects'] = [d for id, d in self._objectIndex.items()]
        return self._fullState

    def set(self, objectId, newValueDict):
        # most of this stuff is deserialized json (comes out of json.loads)
        # and all the dictionary keys generated this way are in unicode
        # so much make sure that's what we're dealing with.
        id = unicode(objectId)
        if id not in self._objectIndex:
            # TODO: obviously we don't want to crash the server just because
            # some joker gives a bad id, so find another way to handle this
            raise Exception('Cant set state, id not found: ' + objectId)
        objectDict = self._objectIndex[id]
        for k, v in newValueDict.items():
            objectDict[k] = v
        self._objectIndex[id] = objectDict


class MessageHandler:
    """
    Singleton class to contain message-handling methods.
    All methods return tuples of envelopes to be sent out.
    """

    def unregisterClient(self, sender):
        """
        Find and delete client from where ever they are registered.
        Triggered from ServerProtocol.connectionLost()
        """
        print "Connection to client {} lost, unregistering.".format(
            sender.peerstr)

        envelopesToSend = []

        # look for them in the lobby
        gameRegistry.lobby.delete(sender)

        # look for them in games
        for game in gameRegistry.getAll():
            if game.hasClient(sender):
                game.deleteClient(sender)
                envelopesToSend.append(game.getPlayersUpdate())

        envelopesToSend.append(gameRegistry.getLobbyUpdate())

        return tuple(envelopesToSend)

    def setObjectProperties(self, sender, msgDict):
        """
        Record changed object property with corresopnding game state and
        broadcast it to other players in the game so they can update.
        """

        print "Updating piece {} with values {}.".format(
            msgDict[u'objectId'], msgDict[u'newValueDict'])

        game = gameRegistry.get(msgDict[u'gameId'])
        game.state.set(msgDict[u'objectId'], msgDict[u'newValueDict'])

        # before broadcasting this change to other players of the game
        # add information about the originator
        msgDict[u'senderId'] = sender.peerstr
        # msgDict[u'senderName'] = sender.peerstr

        # don't send things to back to the sender
        clients = [c for c in game.getClientList() if c.peerstr != sender.peerstr]
        setProp = Envelope(msgDict, clients)

        return (setProp,)

    def enterGame(self, sender, msgDict):
        """
        This client is entering a game. Load the game and provide data
        about it to that client.
        """
        if not gameRegistry.gameExists(msgDict[u'gameId']):
            # this game doesn't exist. but be cool, just send an error back
            badId = Envelope({'messageType': 'error', 'message': 'bad game id'},
                             [sender])
            return (badId,)

        print "Client {} entering game {}.".format(
            sender.peerstr, msgDict[u'gameId'])

        game = gameRegistry.get(msgDict[u'gameId'])
        game.addClient(sender, msgDict[u'userName'])
        returnDict = {'messageType': 'setGameState',
                      'gameId': game.id,
                      'gameState': game.state.get(),
                      'gameName': game.name,
                      'userId': sender.peerstr}
        renderGame = Envelope(returnDict, [sender])

        return (renderGame, game.getPlayersUpdate(),
                gameRegistry.getLobbyUpdate())

    def enterLobby(self, sender, msgDict):
        """Register client with lobby so they can get lobby updates."""

        print "Client {} arriving in lobby.".format(sender.peerstr)
        gameRegistry.lobby.add(sender)
        # send a lobby update, but only for this single client
        gameList = Envelope(gameRegistry.getLobbyUpdate().msgDict, [sender])

        return (gameList,)

    def createGame(self, sender, msgDict):
        """Make a new game. This message type issues from the lobby."""
        print "Creating game: {} - {}".format(
            msgDict[u'gameTypeId'], msgDict[u'gameName'])

        game = Game(msgDict[u'gameTypeId'], msgDict[u'gameName'])
        gameRegistry.add(game)
        returnDict = {'messageType': 'newGameReady', 'gameId': game.id}
        gameReady = Envelope(returnDict, [sender])
        return (gameReady,)

    def loadGame(self, sender, msgDict):
        """Load a saved game. This message type issues from the lobby."""
        print "Loading game {}.".format(msgDict[u'gameId'])

        game = Game.load(msgDict[u'gameId'])
        gameRegistry.add(game)
        returnDict = {'messageType': 'newGameReady',
                      'gameId': game.id,
                      'userName': msgDict[u'userName']}
        gameReady = Envelope(returnDict, [sender])
        return (gameReady,)

    def saveGame(self, sender, msgDict):
        """Save game state to redis db."""
        print "Saving game {}.".format(msgDict[u'gameId'])

        game = gameRegistry.get(msgDict[u'gameId'])
        game.save()
        returnDict = {'messageType': 'gameSaved',
                      'userName': msgDict[u'userName']}
        gameSaved = Envelope(returnDict, game.getClientList())
        return (gameSaved,)

    def listKits(self, sender, msgDict):
        """Get all available kits."""
        print "Listing kits."

        kitIds = redisDb.smembers('allKits')
        pipe = redisDb.pipeline()
        for id in kitIds:
            pipe.hgetall(id)
        kitList1 = pipe.execute()
        # The state data pulled from redis is in a JSON string, while the rest
        # of the kit data is a python dictionary. Unserialize the state so the
        # data is uniformly a python dictionary before sending it back. This
        # avoids double-encoding the state data.
        kitList2 = []
        for kit in kitList1:
            kit['state'] = json.loads(kit['stateString'])
            del(kit['stateString'])
            kitList2.append(kit)
        returnDict = {'messageType': 'kitList', 'data': kitList2}
        returnEnvelope = Envelope(returnDict, [sender])
        return (returnEnvelope,)

    def listGameTypes(self, sender, msgDict):
        """Get all available game types."""
        print "Listing game types."

        gameTypeIds = redisDb.smembers('allGameTypes')
        pipe = redisDb.pipeline()
        for id in gameTypeIds:
            pipe.hgetall(id)
        gList1 = pipe.execute()
        # see comments above in listKits()
        gList2 = []
        for g in gList1:
            g['state'] = json.loads(g['stateString'])
            del(g['stateString'])
            gList2.append(g)
        returnDict = {'messageType': 'gameTypeList', 'data': gList2}
        returnEnvelope = Envelope(returnDict, [sender])
        return (returnEnvelope,)

    def saveKit(self, sender, msgDict):
        """Save a kit of pieces for building."""
        id = 'kit_' + generateRandomString()

        print "Saving new kit {} with id {}.".format(
            msgDict[u'kitName'], id)

        # The JSON string from the server has already been interpreted into
        # a nested python dictionary. We need to re-stringify it so it can
        # be stored all at once in a redis field.
        redisDb.hmset(id, {
            'id': id,
            'name': msgDict[u'kitName'],
            'stateString': json.dumps(msgDict[u'state'])
        })
        redisDb.sadd('allKits', id)

        returnDict = {'messageType': 'kitSaved', 'kitId': id}
        kitSaved = Envelope(returnDict, [sender])
        return (kitSaved,)

    def saveGameType(self, sender, msgDict):
        """Save an initial state for a new type of game."""
        id = 'gameType_' + generateRandomString()

        print "Saving new game type {} with id {}.".format(
            msgDict[u'gameTypeName'], id)

        # The JSON string from the server has already been interpreted into
        # a nested python dictionary. We need to re-stringify it so it can
        # be stored all at once in a redis field.
        redisDb.hmset(id, {
            'id': id,
            'name': msgDict[u'gameTypeName'],
            'stateString': json.dumps(msgDict[u'state'])
        })
        redisDb.sadd('allGameTypes', id)

        returnDict = {'messageType': 'gameTypeSaved', 'gameTypeId': id}
        gameTypeSaved = Envelope(returnDict, [sender])
        return (gameTypeSaved,)

    def deleteKit(self, sender, msgDict):
        print "Deleting kit with id {}.".format(msgDict[u'kitId'])

        id = msgDict[u'kitId']
        redisDb.delete(id)
        redisDb.srem('allKits', id)

        returnDict = {'messageType': 'kitDeleted', 'kitId': id}
        kitDeleted = Envelope(returnDict, [sender])
        return (kitDeleted,)

    def deleteGameType(self, sender, msgDict):
        print "Deleting gameType with id {}.".format(msgDict[u'gameTypeId'])

        id = msgDict[u'gameTypeId']
        redisDb.delete(id)
        redisDb.srem('allGameTypes', id)

        returnDict = {'messageType': 'gameTypeDeleted', 'gameTypeId': id}
        gameTypeDeleted = Envelope(returnDict, [sender])
        return (gameTypeDeleted,)


class ServerProtocol(WebSocketServerProtocol):
    """
    Take actions based on events in the sockets, a.k.a. a client.

    Direct data in the message to a handler method, determined by messageType.
    Handlers return "envelopes": tuples which contain a message to send
    back and a list of clients to send it to. Then dispatch the envelopes.
    """

    def onOpen(self):
        self.factory.register(self)

    def onMessage(self, msgStr, binary):
        if binary:
            raise Exception('handling binary messages not written')

        msgObj = json.loads(msgStr)
        messageType = msgObj[u'messageType']
        handlerMethod = getattr(handler, messageType)
        envelopes = handlerMethod(self, msgObj)
        self.factory.sendEnvelopes(envelopes)

    def connectionLost(self, reason):
        WebSocketServerProtocol.connectionLost(self, reason)

        envelopes = handler.unregisterClient(self)
        self.factory.sendEnvelopes(envelopes)

        self.factory.unregister(self)


class ServerFactory(WebSocketServerFactory):
    """Not sure how this works, got the code from http://autobahn.ws/."""

    def __init__(self, url, debug=False, debugCodePaths=False):
        WebSocketServerFactory.__init__(self, url, debug=debug,
                                        debugCodePaths=debugCodePaths)
        self.clients = []

    def register(self, client):
        if not client in self.clients:
            print "registered client " + client.peerstr
            self.clients.append(client)

    def unregister(self, client):
        if client in self.clients:
            print "unregistered client " + client.peerstr
            self.clients.remove(client)

    def sendToClients(self, msgStr, clients):
        preparedMsg = self.prepareMessage(msgStr)
        for c in clients:
            c.sendPreparedMessage(preparedMsg)
            print "message sent to " + c.peerstr

    def sendEnvelopes(self, envelopes):
        for e in envelopes:
            self.sendToClients(json.dumps(e.msgDict), e.receivingClients)

### MAIN ###

if __name__ == '__main__':
    # set up redis commention
    redisDb = redis.StrictRedis(host='localhost', port=6379, db=0)

    # sorta global
    gameRegistry = GameRegistry()
    handler = MessageHandler()

    factory = ServerFactory("ws://localhost:9000")
    factory.protocol = ServerProtocol
    factory.setProtocolOptions(allowHixie76=True)
    listenWS(factory)

    webdir = File(".")
    web = Site(webdir)
    reactor.listenTCP(8080, web)
    reactor.run()
